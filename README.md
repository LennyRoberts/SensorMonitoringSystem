# A Sensor Device Monitoring System Based on Modbus Protocol

## 写在前面:
- 交叉编译器: gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu
- 如果需要交叉编译到开发板上，请阅读"./compile.arm.sh",修改相应的交叉编译器编译代码，并修改配置文件表
- 如果需要在x86下运行，直接运行"./compile.x86.sh"，注意配置文件的路径
- arm_device.o依赖于配置文件dev_info.csv,并且并调用arm_business.o,此程序依赖于配置文件ser_info.o;将这四个文件放置同一目录下,然后运行arm_device.o
- ps:得美创世(得美设备1.0版本),这是一款截止目前为止仍为开发完成的监测系统，后面如有新的个人需求再修改，并会不断完善；如果你有需求请自行下载，如果您有好的建议，欢迎骚扰，尽管我知道不会有人会看到

## 设备层(device) = 处理层+感知层
### 主要功能:
#### 传感器感知层
1. 对传感器数据进行实时采集、解算、转换，最后缓存到交换队列中
2. 对设备模块状态进行实时采集、解算、转换，最后缓存到封装包里
3. 对传感器进行硬件错误监测，一旦接收到传感器错误信息就立即处理并启动自保护装置

#### 系统层
1. 使用批处理的方式对数据进行降噪、处理与优化
2. 对处理数据后的数据进行封装与向上传递，并对数据进行监测，一旦条件成立则启动相应处理机制
3. 接收上层发来的指令，对指令进行解析、下法和处理
4. 系统层作为unix socket的服务端，可以与上层多个进程的模块进行IPC
5. ISPC处理由硬件串口发送来的指令，并向串口回复如指令处理结果、ModBus数据、JSON数据等

## 维护与更新历史记录
- 更详细的内容请参阅:"./device_layer/README_DEV.md"

| 时间 | 修改位置 | 修改功能 | 新增功能 | 功能简述 | 故障记录 | Bug修复 | 备注 |
| :------: | :-------- | :-------- | :-------- | :-------- | :-------- | :-------- | :-------- |


## 业务逻辑层(Business logic layer)
### 主要功能:
1. 与主服务器及第三方服务器进行TCP通信，上传数据至服务器或接收服务器指令
2. 与系统上位机服务器进行TCP通信，接收上位机指令和上传状态信息至上位机服务器
3. 对系统指令进行解析和处理，然后依据指令规则下发指令至设备层
4. 接收设备层的数据和信息，并对数据和信息进行解析和再封装，依据不同数据上传格式上传至不同服务器
5. 上传控制机制，控制数据和信息的上传规则

## 维护与更新历史记录
- 更详细的内容请参阅:"./business_layer/README_BUSINESS.md"

| 时间 | 修改位置 | 修改功能 | 新增功能 | 功能简述 | 故障记录 | Bug修复 | 备注 |
| :------: | :-------- | :-------- | :-------- | :-------- | :-------- | :-------- | :-------- |


## 本地服务模块
### 主要功能:
1. 接收处理后的处测量数据，用以在本地屏幕数据显示等提供服务

## 维护与更新历史记录
- 更详细的内容请参阅:"./device_layer/local/README_LOCAL.md"

| 时间 | 修改位置 | 修改功能 | 新增功能 | 故障记录 | Bug修复 | 备注 |
| :------: | :-------- | :-------- | :-------- | :-------- | :-------- | :-------- |


## 系统内部统一识别码
| 标识码 | 描述 |
| :---------------------: | :----------- |
| 0x01** ~ 0x16** | 传感器主类(16) |
| 0x17** ~ 0x32** | 传感器副类(16) |
| 0x33** ~ 0x48** | 算法实现类(16  |
| 0x49** ~ 0x64** | 设备功能类(16) |
| 0x65** ~ 0x80** | 外部实现类(16) |
| 0x81** ~ 0x96** | 屏幕显示类(16) |
| 0x97** ~ 0x99** | 保留 |

### 在./device/lib/global_info.h和./business/lib/global_info.h中定义的指令标识码具有三级分类：
1. 一级分类(组别)：划分高八位的每16个为一组，用来表示设备不同组别的功能
2. 二级分类(类别)：每个一级分类下的每一个高八位表示一个类别，用来表示改组别下的该类别，如传感器主类的传感器A类
3. 三级分类(编号)：指令标识码的低八位，在不同组别类别的不同编号指向最终的表示地址

### 在设备维护过程中出现对指令标识码的增、删、改等操作时请遵循以下规则：
1. 每个一级分类(组别)开头要定义起始位置(*_START)和结束位置(*_END)，确保使用和定义的标识码在这个组别/类别中！
2. 一级分类(组别)保持互斥，二级分类(类别)保持互斥，三级分类(编号)在同一类别分类下保持互斥!
3. 每个二级分类(类别)开头要定义该类别的高八位类别号，以及在低八位表示该类别中所含三级分类标识码的个数！
4. 算法标识码具有两重优先级，系统依据优先级别先后执行不同的算法。
5. 算法标识码优先级规则：类别优先级>编号优先级;数值越小优先级越高
